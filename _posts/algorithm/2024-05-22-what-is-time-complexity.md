---
title: '시간 복잡도란?'
excerpt: '자바 코딩 테스트'

published: true

categories: algorithm
tags: algorithm

toc: true
toc_sticky: true

author_profile: false
sidebar:
  nav: 'docs'
---

# 시간 복잡도란?

주어진 문제를 해결하기 위한 연산 횟수  
약 1억 번당 1초로 간주.

즉, 시간 제한이 2초인 문제는 2억 번의 연산 안에 답이 나와야 합니다.  
우리는 코딩 테스트를 볼때 항상 최악의 경우를 먼저 생각하고 시작해야 합니다.

# 시간 복잡도 유형

빅-오메가, 빅-세타, 빅-오  
최선일때, 보통, 최악 일때를 말합니다.

## 빅-오메가 (Big-Omega, Ω)

빅-오메가 표기법은 알고리즘의 최선의 경우 성능을 나타내며, 시간 복잡도의 하한을 나타냅니다. 함수 f(n)이 함수 g(n)에 대해 빅-오메가 표기법을 만족하려면, 다음 조건을 만족해야 합니다.

\[ f(n) = \Omega(g(n)) \]

**공식:**
\[ f(n) \geq c \cdot g(n) \quad \text{for all } n \geq n_0 \]

여기서, c와 \(n_0\)는 양의 상수입니다.

## 빅-세타 (Big-Theta, Θ)

빅-세타 표기법은 알고리즘의 평균 또는 정확한 성능을 나타내며, 시간 복잡도의 상한과 하한을 동시에 나타냅니다. 함수 f(n)이 함수 g(n)에 대해 빅-세타 표기법을 만족하려면, 다음 조건을 만족해야 합니다.

\[ f(n) = \Theta(g(n)) \]

**공식:**
\[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \quad \text{for all } n \geq n_0 \]

여기서, \(c_1\), \(c_2\)와 \(n_0\)는 양의 상수입니다.

## 빅-오 (Big-O, O)

빅-오 표기법은 알고리즘의 최악의 경우 성능을 나타내며, 시간 복잡도의 상한을 나타냅니다. 함수 f(n)이 함수 g(n)에 대해 빅-오 표기법을 만족하려면, 다음 조건을 만족해야 합니다.

\[ f(n) = O(g(n)) \]

**공식:**
\[ f(n) \leq c \cdot g(n) \quad \text{for all } n \geq n_0 \]

여기서, c와 \(n_0\)는 양의 상수입니다.

# 반복문의 시간 복잡도

## 1차 반복문의 시간 복잡도

\[ T(n) = O(n) \] = $O(n)$

## 2차 반복문의 시간 복잡도

\[ T(n) = O(n^2) \] = $O(n^2)$

> 예시

1~100의 숫자에서 랜덤으로 0을 출력을 해야하는 문제가 있다고 해봅니다.

시간 복잡도를 계산할 때는 가장 오래 걸리는 계산 식의 시간 복잡도만 계산 합니다.

1억 번의 1차 반복문 이 여러개 일지라도  
가장 오래 걸리는 계산식은 1억번의 1차 반복문이므로 1초라고 계산합니다.

만약 그 중에 2차 반복문이 존재한다면 $O(n^2)$ 이며  
가장 오래 걸린 2차 반복문 만을 시간 복잡도로 계산합니다.  
즉 2초

---

여기까지 여기까지 알고리즘의 시간 복잡도를 알아보았습니다.
